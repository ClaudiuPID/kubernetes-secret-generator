package main

import (
	"flag"
	"github.com/golang/glog"
	"github.com/mittwald/kubernetes-secret-generator/util"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/pkg/api"
	"k8s.io/client-go/pkg/api/v1"
	"k8s.io/client-go/pkg/runtime"
	"k8s.io/client-go/pkg/util/wait"
	"k8s.io/client-go/pkg/watch"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/tools/clientcmd"
	"math/rand"
	"time"
)

const (
	SecretGenerateAnnotation    = "secret-generator.v1.mittwald.de/autogenerate"
	SecretGeneratedAtAnnotation = "secret-generator.v1.mittwald.de/autogenerate-generated-at"
)

var runes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")

var namespace string
var allNamespaces bool
var kubecfg string

func main() {
	var config *rest.Config

	flag.StringVar(&kubecfg, "kubeconfig", "", "Path to kubeconfig")
	flag.StringVar(&namespace, "namespace", "default", "Namespace")
	flag.BoolVar(&allNamespaces, "all-namespaces", false, "Watch all namespaces")

	flag.Parse()

	if kubecfg == "" {
		config, _ = rest.InClusterConfig()
	} else {
		config, _ = clientcmd.BuildConfigFromFlags("", kubecfg)
	}

	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err)
	}

	gc := GeneratorController{
		client: client,
	}

	if allNamespaces {
		namespace = ""
	}

	_, controller := cache.NewInformer(
		&cache.ListWatch{
			ListFunc: func(alo api.ListOptions) (runtime.Object, error) {
				var lo v1.ListOptions
				v1.Convert_api_ListOptions_To_v1_ListOptions(&alo, &lo, nil)

				return client.Core().Secrets(namespace).List(lo)
			},
			WatchFunc: func(alo api.ListOptions) (watch.Interface, error) {
				var lo v1.ListOptions
				v1.Convert_api_ListOptions_To_v1_ListOptions(&alo, &lo, nil)

				return client.Core().Secrets(namespace).Watch(lo)
			},
		},
		&v1.Secret{},
		30*time.Minute,
		cache.ResourceEventHandlerFuncs{
			AddFunc:    gc.SecretAdded,
			UpdateFunc: func(old interface{}, new interface{}) { gc.SecretAdded(new) },
			DeleteFunc: func(new interface{}) {},
		},
	)

	gc.controller = controller

	controller.Run(wait.NeverStop)
}

type GeneratorController struct {
	client     kubernetes.Interface
	controller cache.ControllerInterface
}

func (c *GeneratorController) SecretAdded(obj interface{}) {
	secret := obj.(*v1.Secret)

	glog.Infof("found secret: %s", secret.Name)

	if val, ok := secret.Annotations[SecretGenerateAnnotation]; ok {
		glog.Infof("secret %s is autogenerated", secret.Name)

		if _, ok := secret.Annotations[SecretGeneratedAtAnnotation]; ok {
			glog.Infof("secret %s already contains autogenerated property", secret.Name)
			return
		}

		secretCopy, err := util.CopyObjToSecret(secret)
		if err != nil {
			glog.Errorf("could not copy secret %s: %s", secret.Name, err)
			return
		}

		newPassword, err := generateSecret(40)
		if err != nil {
			glog.Errorf("could not generate new secret: %s", err)
			return
		}

		secretCopy.Annotations[SecretGeneratedAtAnnotation] = time.Now().String()
		secretCopy.Data[val] = []byte(newPassword)

		if _, err := c.client.Core().Secrets(secret.Namespace).Update(secretCopy); err != nil {
			glog.Errorf("could not add %s annotation to secret %s: %s", SecretGeneratedAtAnnotation, secret.Name, err)
			return
		}
	}

}

func generateSecret(length int) (string, error) {
	b := make([]rune, length)
	for i := range b {
		b[i] = runes[rand.Intn(len(runes))]
	}
	return string(b), nil
}
